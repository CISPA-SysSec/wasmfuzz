diff --git a/src/elf/mod.rs b/src/elf/mod.rs
index 8fe49d9..5ee1a97 100644
--- a/src/elf/mod.rs
+++ b/src/elf/mod.rs
@@ -399,7 +399,7 @@ if_sylvan! {
                     .chain(pltrelocs.iter())
                     .fold(0, |num, reloc| cmp::max(num, reloc.r_sym));
                 if max_reloc_sym != 0 {
-                    num_syms = cmp::max(num_syms, max_reloc_sym + 1);
+                    num_syms = cmp::max(num_syms, max_reloc_sym.saturating_add(1));
                 }
                 dynsyms = Symtab::parse_with_opts(bytes, dyn_info.symtab, num_syms, ctx, opts)?;
             }
@@ -483,10 +483,10 @@ if_sylvan! {
                                                        buckets_num, min_chain, bloom_size)));
         }
         // Find the last bucket.
-        let buckets_offset = offset + 16 + bloom_size * if ctx.container.is_big() { 8 } else { 4 };
+        let buckets_offset = (offset + 16).saturating_add(bloom_size.saturating_mul(if ctx.container.is_big() { 8 } else { 4 }));
         let mut max_chain = 0;
         for bucket in 0..buckets_num {
-            let chain = bytes.pread_with::<u32>(buckets_offset + bucket * 4, ctx.le)? as usize;
+            let chain = bytes.pread_with::<u32>(buckets_offset.saturating_add(bucket * 4), ctx.le)? as usize;
             if max_chain < chain {
                 max_chain = chain;
             }
@@ -495,7 +495,7 @@ if_sylvan! {
             return Ok(0);
         }
         // Find the last chain within the bucket.
-        let mut chain_offset = buckets_offset + buckets_num * 4 + (max_chain - min_chain) * 4;
+        let mut chain_offset = (buckets_offset + buckets_num * 4).saturating_add((max_chain.saturating_sub(min_chain)).saturating_mul(4));
         loop {
             let hash = bytes.pread_with::<u32>(chain_offset, ctx.le)?;
             max_chain += 1;
diff --git a/src/pe/debug.rs b/src/pe/debug.rs
index c7e673f..2bf3c87 100644
--- a/src/pe/debug.rs
+++ b/src/pe/debug.rs
@@ -187,7 +187,7 @@ impl<'a> DebugData<'a> {
             };
 
         // Ensure that the offset and size do not exceed the length of the bytes slice
-        let available_size = if offset + dd.size as usize > bytes.len() {
+        let available_size = if offset.saturating_add(dd.size as usize) > bytes.len() {
             let remaining_bytes = bytes.len().saturating_sub(offset);
             Err(error::Error::Malformed(format!(
                 "ImageDebugDirectory offset {:#x} and size {:#x} exceeds the bounds of the bytes size {:#x}. \
